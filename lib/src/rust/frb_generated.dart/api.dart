// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `run_blocking`

Future<void> setNodeUrl({required String url}) =>
    RustLib.instance.api.crateApiSetNodeUrl(url: url);

Future<String> getNodeUrl() => RustLib.instance.api.crateApiGetNodeUrl();

Future<BigInt> getNodeTip() => RustLib.instance.api.crateApiGetNodeTip();

Future<void> walletInitOrOpen(
        {required String dataDir, required String passphrase}) =>
    RustLib.instance.api
        .crateApiWalletInitOrOpen(dataDir: dataDir, passphrase: passphrase);

Future<String> walletCreate(
        {required String dataDir,
        required String passphrase,
        required BigInt mnemonicLength}) =>
    RustLib.instance.api.crateApiWalletCreate(
        dataDir: dataDir,
        passphrase: passphrase,
        mnemonicLength: mnemonicLength);

Future<String> walletSeedPhrase(
        {required String dataDir, required String passphrase}) =>
    RustLib.instance.api
        .crateApiWalletSeedPhrase(dataDir: dataDir, passphrase: passphrase);

Future<void> walletRestoreFromSeed(
        {required String dataDir,
        required String passphrase,
        required String phrase}) =>
    RustLib.instance.api.crateApiWalletRestoreFromSeed(
        dataDir: dataDir, passphrase: passphrase, phrase: phrase);

Future<String> walletGetAddress() =>
    RustLib.instance.api.crateApiWalletGetAddress();

Future<void> walletSync() => RustLib.instance.api.crateApiWalletSync();

Future<BigInt> walletGetBalance() =>
    RustLib.instance.api.crateApiWalletGetBalance();

Future<String> walletSendSlatepack(
        {required String to, required BigInt amountNano}) =>
    RustLib.instance.api
        .crateApiWalletSendSlatepack(to: to, amountNano: amountNano);

Future<String> walletIssueInvoice({required BigInt amountNano}) =>
    RustLib.instance.api.crateApiWalletIssueInvoice(amountNano: amountNano);

Future<String> walletReceiveSlatepack({required String message}) =>
    RustLib.instance.api.crateApiWalletReceiveSlatepack(message: message);

Future<String> walletProcessInvoice({required String message}) =>
    RustLib.instance.api.crateApiWalletProcessInvoice(message: message);

Future<String> walletInspectSlatepack({required String message}) =>
    RustLib.instance.api.crateApiWalletInspectSlatepack(message: message);

Future<String> walletFinalizeSlatepack(
        {required String message, required bool postTx, required bool fluff}) =>
    RustLib.instance.api.crateApiWalletFinalizeSlatepack(
        message: message, postTx: postTx, fluff: fluff);

Future<String> walletInfo() => RustLib.instance.api.crateApiWalletInfo();

Future<String> walletListTransactions({required bool refreshFromNode}) =>
    RustLib.instance.api
        .crateApiWalletListTransactions(refreshFromNode: refreshFromNode);

Future<String> walletListOutputs(
        {required bool includeSpent, required bool refreshFromNode}) =>
    RustLib.instance.api.crateApiWalletListOutputs(
        includeSpent: includeSpent, refreshFromNode: refreshFromNode);

Future<void> walletCancelTx({required int txId}) =>
    RustLib.instance.api.crateApiWalletCancelTx(txId: txId);

Future<void> walletRepostTx({required int txId, required bool fluff}) =>
    RustLib.instance.api.crateApiWalletRepostTx(txId: txId, fluff: fluff);

Future<String> walletScan(
        {required bool deleteUnconfirmed,
        BigInt? startHeight,
        BigInt? backwardsFromTip}) =>
    RustLib.instance.api.crateApiWalletScan(
        deleteUnconfirmed: deleteUnconfirmed,
        startHeight: startHeight,
        backwardsFromTip: backwardsFromTip);

Future<String> walletListAccounts() =>
    RustLib.instance.api.crateApiWalletListAccounts();

Future<String> walletCreateAccount({required String label}) =>
    RustLib.instance.api.crateApiWalletCreateAccount(label: label);

Future<String> walletSetActiveAccount({required String label}) =>
    RustLib.instance.api.crateApiWalletSetActiveAccount(label: label);

Future<String> walletActiveAccount() =>
    RustLib.instance.api.crateApiWalletActiveAccount();

Future<String> walletPaymentProof({required int txId}) =>
    RustLib.instance.api.crateApiWalletPaymentProof(txId: txId);

Future<String> walletTransactionSlatepack({required int txId}) =>
    RustLib.instance.api.crateApiWalletTransactionSlatepack(txId: txId);

Future<String> walletVerifyPaymentProof({required String payload}) =>
    RustLib.instance.api.crateApiWalletVerifyPaymentProof(payload: payload);

Future<String> torStatus() => RustLib.instance.api.crateApiTorStatus();

Future<String> torStart({required String listenAddr}) =>
    RustLib.instance.api.crateApiTorStart(listenAddr: listenAddr);

Future<void> torStop() => RustLib.instance.api.crateApiTorStop();

Future<String> ownerListenerStatus() =>
    RustLib.instance.api.crateApiOwnerListenerStatus();

Future<String> ownerListenerStart() =>
    RustLib.instance.api.crateApiOwnerListenerStart();

Future<String> atomicSwapInit(
        {required String fromCurrency,
        required String toCurrency,
        required BigInt fromAmount,
        required BigInt toAmount,
        required BigInt timeoutMinutes}) =>
    RustLib.instance.api.crateApiAtomicSwapInit(
        fromCurrency: fromCurrency,
        toCurrency: toCurrency,
        fromAmount: fromAmount,
        toAmount: toAmount,
        timeoutMinutes: timeoutMinutes);

Future<String> atomicSwapAccept({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapAccept(swapId: swapId);

Future<String> atomicSwapRead({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapRead(swapId: swapId);

Future<String> atomicSwapList() =>
    RustLib.instance.api.crateApiAtomicSwapList();

Future<String> atomicSwapChecksum({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapChecksum(swapId: swapId);

Future<String> atomicSwapSetDirectory({required String path}) =>
    RustLib.instance.api.crateApiAtomicSwapSetDirectory(path: path);

Future<String> atomicSwapSetPeer(
        {required String host, required String port}) =>
    RustLib.instance.api.crateApiAtomicSwapSetPeer(host: host, port: port);

Future<String> atomicSwapLock({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapLock(swapId: swapId);

Future<String> atomicSwapExecute({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapExecute(swapId: swapId);

Future<String> atomicSwapCancel({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapCancel(swapId: swapId);

Future<String> atomicSwapDelete({required BigInt swapId}) =>
    RustLib.instance.api.crateApiAtomicSwapDelete(swapId: swapId);

Future<String> atomicSwapImport(
        {required BigInt swapId, required String payload}) =>
    RustLib.instance.api
        .crateApiAtomicSwapImport(swapId: swapId, payload: payload);
